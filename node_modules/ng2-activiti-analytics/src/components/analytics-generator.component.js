/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require("@angular/core");
var ng2_alfresco_core_1 = require("ng2-alfresco-core");
var analytics_service_1 = require("../services/analytics.service");
var report_model_1 = require("../models/report.model");
var AnalyticsGeneratorComponent = (function () {
    function AnalyticsGeneratorComponent(translateService, analyticsService, logService) {
        this.translateService = translateService;
        this.analyticsService = analyticsService;
        this.logService = logService;
        this.reportParamQuery = undefined;
        this.onSuccess = new core_1.EventEmitter();
        this.onError = new core_1.EventEmitter();
        this.showDetails = false;
        this.barChartOptions = {
            responsive: true,
            scales: {
                yAxes: [{
                        ticks: {
                            beginAtZero: true,
                            stepSize: 1
                        }
                    }],
                xAxes: [{
                        ticks: {},
                        stacked: true
                    }]
            }
        };
        logService.info('AnalyticsGeneratorComponent');
        if (translateService) {
            translateService.addTranslationFolder('ng2-activiti-analytics', 'node_modules/ng2-activiti-analytics/src');
        }
    }
    AnalyticsGeneratorComponent.prototype.ngOnChanges = function (changes) {
        if (this.reportId && this.reportParamQuery) {
            this.generateReport(this.reportId, this.reportParamQuery);
        }
        else {
            this.reset();
        }
    };
    AnalyticsGeneratorComponent.prototype.generateReport = function (reportId, reportParamQuery) {
        var _this = this;
        this.analyticsService.getReportsByParams(reportId, reportParamQuery).subscribe(function (res) {
            _this.reports = res;
            _this.onSuccess.emit(res);
        }, function (err) {
            _this.onError.emit(err);
            _this.logService.error(err);
        });
    };
    AnalyticsGeneratorComponent.prototype.reset = function () {
        if (this.reports) {
            this.reports = undefined;
        }
    };
    AnalyticsGeneratorComponent.prototype.refresh = function (report) {
        var clone = JSON.parse(JSON.stringify(report));
        report.datasets = clone.datasets;
    };
    AnalyticsGeneratorComponent.prototype.toggleDetailsTable = function () {
        this.showDetails = !this.showDetails;
    };
    AnalyticsGeneratorComponent.prototype.isShowDetails = function () {
        return this.showDetails;
    };
    return AnalyticsGeneratorComponent;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Number)
], AnalyticsGeneratorComponent.prototype, "reportId", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", report_model_1.ReportQuery)
], AnalyticsGeneratorComponent.prototype, "reportParamQuery", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", Object)
], AnalyticsGeneratorComponent.prototype, "onSuccess", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", Object)
], AnalyticsGeneratorComponent.prototype, "onError", void 0);
AnalyticsGeneratorComponent = __decorate([
    core_1.Component({
        moduleId: module.id,
        selector: 'activiti-analytics-generator',
        template: "<div *ngIf=\"reports\">     <div *ngFor=\"let report of reports\">         <h4>{{report.title}}</h4>         <div [ngSwitch]=\"report.type\">             <div *ngSwitchCase=\"'pie'\">                 <div class=\"col-md-6\">                     <div *ngIf=\"!report.hasData()\">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>                     <div *ngIf=\"report.hasData()\">                         <div *ngIf=\"report.hasZeroValues()\">{{'ANALYTICS.MESSAGES.ZERO-DATA-FOUND' | translate}}</div>                         <base-chart *ngIf=\"!report.hasZeroValues()\" class=\"chart\"                                     [data]=\"report.data\"                                     [labels]=\"report.labels\"                                     [chartType]=\"report.type\"></base-chart>                     </div>                 </div>             </div>             <div *ngSwitchCase=\"'table'\">                 <div *ngIf=\"!report.hasDatasets()\">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>                 <div [attr.id]=\"'chart-table-' + report.id\" *ngIf=\"report.hasDatasets()\">                     <table class=\"table table-responsive table-condensed\" style=\"width: 100%\">                         <tr>                             <th *ngFor=\"let label of report.labels\">{{label | translate}}</th>                         </tr>                         <tr *ngFor=\"let rows of report.datasets\" style=\"text-align: center;\">                             <td *ngFor=\"let row of rows\">{{row | translate }}</td>                         </tr>                     </table>                 </div>             </div>             <div *ngSwitchCase=\"'masterDetailTable'\">                 <div *ngIf=\"!report.hasDatasets()\">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>                 <div [attr.id]=\"'chart-master-detail-table-' + report.id\" *ngIf=\"report.hasDatasets()\">                     <table class=\"table table-responsive table-condensed\" style=\"width: 100%\">                         <tr>                             <th *ngFor=\"let label of report.labels\">{{label | translate}}</th>                         </tr>                         <tr *ngFor=\"let rows of report.datasets\" class=\"analytics-row__entry\" style=\"text-align: center;\">                             <td *ngFor=\"let row of rows\" (click)=\"toggleDetailsTable()\">{{row | translate }}</td>                         </tr>                     </table>                 </div>                 <div [attr.id]=\"'chart-master-detail-' + report.id\" *ngIf=\"isShowDetails()\">                     <table class=\"table table-responsive table-condensed\" style=\"width: 100%\">                         <tr>                             <th *ngFor=\"let label of report.detailsTable.labels\">{{label | translate}}</th>                         </tr>                         <tr *ngFor=\"let rows of report.detailsTable.datasets\" style=\"text-align: center;\">                             <td *ngFor=\"let row of rows\">{{row | translate }}</td>                         </tr>                     </table>                 </div>             </div>             <div *ngSwitchCase=\"'bar'\">                 <div class=\"col-md-6\">                     <div *ngIf=\"!report.hasDatasets()\">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>                     <base-chart *ngIf=\"report.hasDatasets()\" class=\"chart\"                                 [datasets]=\"report.datasets\"                                 [labels]=\"report.labels\"                                 [options]=\"report.options\"                                 [chartType]=\"report.type\"></base-chart>                 </div>             </div>             <div *ngSwitchCase=\"'multiBar'\">                 <div class=\"col-md-6\">                     <div *ngIf=\"!report.hasDatasets()\">{{'ANALYTICS.MESSAGES.NO-DATA-FOUND' | translate}}</div>                     <div *ngIf=\"report.hasDatasets()\">                         <label class=\"mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect\" [attr.for]=\"'stacked-id'\">                             <input type=\"checkbox\" [attr.id]=\"'stacked-id'\" class=\"mdl-checkbox__input\"                                    [checked]=\"report.options.scales.xAxes[0].stacked\"                                    [(ngModel)]=\"report.options.scales.xAxes[0].stacked\"                                    (change)=\"refresh(report)\">                             <span class=\"mdl-checkbox__label\">Stacked</span>                         </label>                         <base-chart class=\"chart\"                                     [datasets]=\"report.datasets\"                                     [labels]=\"report.labels\"                                     [options]=\"report.options\"                                     [chartType]=\"'bar'\"></base-chart>                     </div>                 </div>             </div>             <div *ngSwitchCase=\"'HeatMap'\">                 <analytics-report-heat-map [report]=\"report\"></analytics-report-heat-map>             </div>             <div *ngSwitchDefault>                 <span>{{'ANALYTICS.MESSAGES.UNKNOWN-WIDGET-TYPE' | translate}}: {{report.type}}</span>             </div>         </div>     </div> </div> <br><br><br> <div *ngIf=\"!reports\">{{'ANALYTICS.MESSAGES.FILL-PARAMETER' | translate}}</div>",
        styles: [".chart {display: block; width: 100%;}  .analytics-row__entry {     cursor: pointer; }"]
    }),
    __metadata("design:paramtypes", [ng2_alfresco_core_1.AlfrescoTranslationService,
        analytics_service_1.AnalyticsService,
        ng2_alfresco_core_1.LogService])
], AnalyticsGeneratorComponent);
exports.AnalyticsGeneratorComponent = AnalyticsGeneratorComponent;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvYW5hbHl0aWNzLWdlbmVyYXRvci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOzs7Ozs7Ozs7OztBQUVILHNDQUFpRztBQUNqRyx1REFBMkU7QUFDM0UsbUVBQWlFO0FBQ2pFLHVEQUFxRDtBQVNyRCxJQUFhLDJCQUEyQjtJQW1DcEMscUNBQW9CLGdCQUE0QyxFQUM1QyxnQkFBa0MsRUFDbEMsVUFBc0I7UUFGdEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUE0QjtRQUM1QyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBQ2xDLGVBQVUsR0FBVixVQUFVLENBQVk7UUEvQjFDLHFCQUFnQixHQUFnQixTQUFTLENBQUM7UUFHMUMsY0FBUyxHQUFHLElBQUksbUJBQVksRUFBRSxDQUFDO1FBRy9CLFlBQU8sR0FBRyxJQUFJLG1CQUFZLEVBQUUsQ0FBQztRQUk3QixnQkFBVyxHQUFZLEtBQUssQ0FBQztRQUV0QixvQkFBZSxHQUFRO1lBQzFCLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLE1BQU0sRUFBRTtnQkFDSixLQUFLLEVBQUUsQ0FBQzt3QkFDSixLQUFLLEVBQUU7NEJBQ0gsV0FBVyxFQUFFLElBQUk7NEJBQ2pCLFFBQVEsRUFBRSxDQUFDO3lCQUNkO3FCQUNKLENBQUM7Z0JBQ0YsS0FBSyxFQUFFLENBQUM7d0JBQ0osS0FBSyxFQUFFLEVBQ047d0JBQ0QsT0FBTyxFQUFFLElBQUk7cUJBQ2hCLENBQUM7YUFDTDtTQUNKLENBQUM7UUFLRSxVQUFVLENBQUMsSUFBSSxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDL0MsRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQ25CLGdCQUFnQixDQUFDLG9CQUFvQixDQUFDLHdCQUF3QixFQUFFLHlDQUF5QyxDQUFDLENBQUM7UUFDL0csQ0FBQztJQUNMLENBQUM7SUFFRCxpREFBVyxHQUFYLFVBQVksT0FBc0I7UUFDOUIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQ3pDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztRQUM5RCxDQUFDO1FBQUMsSUFBSSxDQUFDLENBQUM7WUFDSixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDakIsQ0FBQztJQUNMLENBQUM7SUFFTSxvREFBYyxHQUFyQixVQUFzQixRQUFRLEVBQUUsZ0JBQWdCO1FBQWhELGlCQVdDO1FBVkcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDLFNBQVMsQ0FDMUUsVUFBQyxHQUFZO1lBQ1QsS0FBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7WUFDbkIsS0FBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDN0IsQ0FBQyxFQUNELFVBQUMsR0FBUTtZQUNMLEtBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3ZCLEtBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FDSixDQUFDO0lBQ04sQ0FBQztJQUVNLDJDQUFLLEdBQVo7UUFDSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO1FBQzdCLENBQUM7SUFDTCxDQUFDO0lBRU0sNkNBQU8sR0FBZCxVQUFlLE1BQU07UUFPakIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDL0MsTUFBTSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQ3JDLENBQUM7SUFFRCx3REFBa0IsR0FBbEI7UUFDSSxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUN6QyxDQUFDO0lBRUQsbURBQWEsR0FBYjtRQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzVCLENBQUM7SUFDTCxrQ0FBQztBQUFELENBekZBLEFBeUZDLElBQUE7QUF0Rkc7SUFEQyxZQUFLLEVBQUU7OzZEQUNTO0FBR2pCO0lBREMsWUFBSyxFQUFFOzhCQUNVLDBCQUFXO3FFQUFhO0FBRzFDO0lBREMsYUFBTSxFQUFFOzs4REFDc0I7QUFHL0I7SUFEQyxhQUFNLEVBQUU7OzREQUNvQjtBQVpwQiwyQkFBMkI7SUFOdkMsZ0JBQVMsQ0FBQztRQUNQLFFBQVEsRUFBRSxNQUFNLENBQUMsRUFBRTtRQUNuQixRQUFRLEVBQUUsOEJBQThCO1FBQ3hDLFFBQVEsRUFBRSw2eUtBQTZ5SztRQUN2ekssTUFBTSxFQUFFLENBQUMsdUZBQXVGLENBQUM7S0FDcEcsQ0FBQztxQ0FvQ3dDLDhDQUEwQjtRQUMxQixvQ0FBZ0I7UUFDdEIsOEJBQVU7R0FyQ2pDLDJCQUEyQixDQXlGdkM7QUF6Rlksa0VBQTJCIiwiZmlsZSI6ImNvbXBvbmVudHMvYW5hbHl0aWNzLWdlbmVyYXRvci5jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBJbnB1dCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbGZyZXNjb1RyYW5zbGF0aW9uU2VydmljZSwgTG9nU2VydmljZSB9IGZyb20gJ25nMi1hbGZyZXNjby1jb3JlJztcbmltcG9ydCB7IEFuYWx5dGljc1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy9hbmFseXRpY3Muc2VydmljZSc7XG5pbXBvcnQgeyBSZXBvcnRRdWVyeSB9IGZyb20gJy4uL21vZGVscy9yZXBvcnQubW9kZWwnO1xuaW1wb3J0IHsgQ2hhcnQgfSBmcm9tICcuLi9tb2RlbHMvY2hhcnQubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBtb2R1bGVJZDogbW9kdWxlLmlkLFxuICAgIHNlbGVjdG9yOiAnYWN0aXZpdGktYW5hbHl0aWNzLWdlbmVyYXRvcicsXG4gICAgdGVtcGxhdGU6IFwiPGRpdiAqbmdJZj1cXFwicmVwb3J0c1xcXCI+ICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IHJlcG9ydCBvZiByZXBvcnRzXFxcIj4gICAgICAgICA8aDQ+e3tyZXBvcnQudGl0bGV9fTwvaDQ+ICAgICAgICAgPGRpdiBbbmdTd2l0Y2hdPVxcXCJyZXBvcnQudHlwZVxcXCI+ICAgICAgICAgICAgIDxkaXYgKm5nU3dpdGNoQ2FzZT1cXFwiJ3BpZSdcXFwiPiAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPiAgICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFyZXBvcnQuaGFzRGF0YSgpXFxcIj57eydBTkFMWVRJQ1MuTUVTU0FHRVMuTk8tREFUQS1GT1VORCcgfCB0cmFuc2xhdGV9fTwvZGl2PiAgICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcInJlcG9ydC5oYXNEYXRhKClcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJyZXBvcnQuaGFzWmVyb1ZhbHVlcygpXFxcIj57eydBTkFMWVRJQ1MuTUVTU0FHRVMuWkVSTy1EQVRBLUZPVU5EJyB8IHRyYW5zbGF0ZX19PC9kaXY+ICAgICAgICAgICAgICAgICAgICAgICAgIDxiYXNlLWNoYXJ0ICpuZ0lmPVxcXCIhcmVwb3J0Lmhhc1plcm9WYWx1ZXMoKVxcXCIgY2xhc3M9XFxcImNoYXJ0XFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGF0YV09XFxcInJlcG9ydC5kYXRhXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxzXT1cXFwicmVwb3J0LmxhYmVsc1xcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NoYXJ0VHlwZV09XFxcInJlcG9ydC50eXBlXFxcIj48L2Jhc2UtY2hhcnQ+ICAgICAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgIDxkaXYgKm5nU3dpdGNoQ2FzZT1cXFwiJ3RhYmxlJ1xcXCI+ICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhcmVwb3J0Lmhhc0RhdGFzZXRzKClcXFwiPnt7J0FOQUxZVElDUy5NRVNTQUdFUy5OTy1EQVRBLUZPVU5EJyB8IHRyYW5zbGF0ZX19PC9kaXY+ICAgICAgICAgICAgICAgICA8ZGl2IFthdHRyLmlkXT1cXFwiJ2NoYXJ0LXRhYmxlLScgKyByZXBvcnQuaWRcXFwiICpuZ0lmPVxcXCJyZXBvcnQuaGFzRGF0YXNldHMoKVxcXCI+ICAgICAgICAgICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1yZXNwb25zaXZlIHRhYmxlLWNvbmRlbnNlZFxcXCIgc3R5bGU9XFxcIndpZHRoOiAxMDAlXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgPHRyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRoICpuZ0Zvcj1cXFwibGV0IGxhYmVsIG9mIHJlcG9ydC5sYWJlbHNcXFwiPnt7bGFiZWwgfCB0cmFuc2xhdGV9fTwvdGg+ICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+ICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCByb3dzIG9mIHJlcG9ydC5kYXRhc2V0c1xcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cXFwibGV0IHJvdyBvZiByb3dzXFxcIj57e3JvdyB8IHRyYW5zbGF0ZSB9fTwvdGQ+ICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+ICAgICAgICAgICAgICAgICAgICAgPC90YWJsZT4gICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgPGRpdiAqbmdTd2l0Y2hDYXNlPVxcXCInbWFzdGVyRGV0YWlsVGFibGUnXFxcIj4gICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFyZXBvcnQuaGFzRGF0YXNldHMoKVxcXCI+e3snQU5BTFlUSUNTLk1FU1NBR0VTLk5PLURBVEEtRk9VTkQnIHwgdHJhbnNsYXRlfX08L2Rpdj4gICAgICAgICAgICAgICAgIDxkaXYgW2F0dHIuaWRdPVxcXCInY2hhcnQtbWFzdGVyLWRldGFpbC10YWJsZS0nICsgcmVwb3J0LmlkXFxcIiAqbmdJZj1cXFwicmVwb3J0Lmhhc0RhdGFzZXRzKClcXFwiPiAgICAgICAgICAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtcmVzcG9uc2l2ZSB0YWJsZS1jb25kZW5zZWRcXFwiIHN0eWxlPVxcXCJ3aWR0aDogMTAwJVxcXCI+ICAgICAgICAgICAgICAgICAgICAgICAgIDx0cj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0aCAqbmdGb3I9XFxcImxldCBsYWJlbCBvZiByZXBvcnQubGFiZWxzXFxcIj57e2xhYmVsIHwgdHJhbnNsYXRlfX08L3RoPiAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPiAgICAgICAgICAgICAgICAgICAgICAgICA8dHIgKm5nRm9yPVxcXCJsZXQgcm93cyBvZiByZXBvcnQuZGF0YXNldHNcXFwiIGNsYXNzPVxcXCJhbmFseXRpY3Mtcm93X19lbnRyeVxcXCIgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHRkICpuZ0Zvcj1cXFwibGV0IHJvdyBvZiByb3dzXFxcIiAoY2xpY2spPVxcXCJ0b2dnbGVEZXRhaWxzVGFibGUoKVxcXCI+e3tyb3cgfCB0cmFuc2xhdGUgfX08L3RkPiAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPiAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+ICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgIDxkaXYgW2F0dHIuaWRdPVxcXCInY2hhcnQtbWFzdGVyLWRldGFpbC0nICsgcmVwb3J0LmlkXFxcIiAqbmdJZj1cXFwiaXNTaG93RGV0YWlscygpXFxcIj4gICAgICAgICAgICAgICAgICAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIHRhYmxlLXJlc3BvbnNpdmUgdGFibGUtY29uZGVuc2VkXFxcIiBzdHlsZT1cXFwid2lkdGg6IDEwMCVcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICA8dHI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGggKm5nRm9yPVxcXCJsZXQgbGFiZWwgb2YgcmVwb3J0LmRldGFpbHNUYWJsZS5sYWJlbHNcXFwiPnt7bGFiZWwgfCB0cmFuc2xhdGV9fTwvdGg+ICAgICAgICAgICAgICAgICAgICAgICAgIDwvdHI+ICAgICAgICAgICAgICAgICAgICAgICAgIDx0ciAqbmdGb3I9XFxcImxldCByb3dzIG9mIHJlcG9ydC5kZXRhaWxzVGFibGUuZGF0YXNldHNcXFwiIHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCAqbmdGb3I9XFxcImxldCByb3cgb2Ygcm93c1xcXCI+e3tyb3cgfCB0cmFuc2xhdGUgfX08L3RkPiAgICAgICAgICAgICAgICAgICAgICAgICA8L3RyPiAgICAgICAgICAgICAgICAgICAgIDwvdGFibGU+ICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgIDxkaXYgKm5nU3dpdGNoQ2FzZT1cXFwiJ2JhcidcXFwiPiAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29sLW1kLTZcXFwiPiAgICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XFxcIiFyZXBvcnQuaGFzRGF0YXNldHMoKVxcXCI+e3snQU5BTFlUSUNTLk1FU1NBR0VTLk5PLURBVEEtRk9VTkQnIHwgdHJhbnNsYXRlfX08L2Rpdj4gICAgICAgICAgICAgICAgICAgICA8YmFzZS1jaGFydCAqbmdJZj1cXFwicmVwb3J0Lmhhc0RhdGFzZXRzKClcXFwiIGNsYXNzPVxcXCJjaGFydFxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGF0YXNldHNdPVxcXCJyZXBvcnQuZGF0YXNldHNcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsc109XFxcInJlcG9ydC5sYWJlbHNcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnNdPVxcXCJyZXBvcnQub3B0aW9uc1xcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2hhcnRUeXBlXT1cXFwicmVwb3J0LnR5cGVcXFwiPjwvYmFzZS1jaGFydD4gICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgPGRpdiAqbmdTd2l0Y2hDYXNlPVxcXCInbXVsdGlCYXInXFxcIj4gICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbC1tZC02XFxcIj4gICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhcmVwb3J0Lmhhc0RhdGFzZXRzKClcXFwiPnt7J0FOQUxZVElDUy5NRVNTQUdFUy5OTy1EQVRBLUZPVU5EJyB8IHRyYW5zbGF0ZX19PC9kaXY+ICAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cXFwicmVwb3J0Lmhhc0RhdGFzZXRzKClcXFwiPiAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcIm1kbC1jaGVja2JveCBtZGwtanMtY2hlY2tib3ggbWRsLWpzLXJpcHBsZS1lZmZlY3RcXFwiIFthdHRyLmZvcl09XFxcIidzdGFja2VkLWlkJ1xcXCI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFthdHRyLmlkXT1cXFwiJ3N0YWNrZWQtaWQnXFxcIiBjbGFzcz1cXFwibWRsLWNoZWNrYm94X19pbnB1dFxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2hlY2tlZF09XFxcInJlcG9ydC5vcHRpb25zLnNjYWxlcy54QXhlc1swXS5zdGFja2VkXFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVxcXCJyZXBvcnQub3B0aW9ucy5zY2FsZXMueEF4ZXNbMF0uc3RhY2tlZFxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlKT1cXFwicmVmcmVzaChyZXBvcnQpXFxcIj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtZGwtY2hlY2tib3hfX2xhYmVsXFxcIj5TdGFja2VkPC9zcGFuPiAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgICAgICAgICAgICAgICAgICA8YmFzZS1jaGFydCBjbGFzcz1cXFwiY2hhcnRcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRhc2V0c109XFxcInJlcG9ydC5kYXRhc2V0c1xcXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsc109XFxcInJlcG9ydC5sYWJlbHNcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcHRpb25zXT1cXFwicmVwb3J0Lm9wdGlvbnNcXFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjaGFydFR5cGVdPVxcXCInYmFyJ1xcXCI+PC9iYXNlLWNoYXJ0PiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICA8ZGl2ICpuZ1N3aXRjaENhc2U9XFxcIidIZWF0TWFwJ1xcXCI+ICAgICAgICAgICAgICAgICA8YW5hbHl0aWNzLXJlcG9ydC1oZWF0LW1hcCBbcmVwb3J0XT1cXFwicmVwb3J0XFxcIj48L2FuYWx5dGljcy1yZXBvcnQtaGVhdC1tYXA+ICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICA8ZGl2ICpuZ1N3aXRjaERlZmF1bHQ+ICAgICAgICAgICAgICAgICA8c3Bhbj57eydBTkFMWVRJQ1MuTUVTU0FHRVMuVU5LTk9XTi1XSURHRVQtVFlQRScgfCB0cmFuc2xhdGV9fToge3tyZXBvcnQudHlwZX19PC9zcGFuPiAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICA8L2Rpdj4gICAgIDwvZGl2PiA8L2Rpdj4gPGJyPjxicj48YnI+IDxkaXYgKm5nSWY9XFxcIiFyZXBvcnRzXFxcIj57eydBTkFMWVRJQ1MuTUVTU0FHRVMuRklMTC1QQVJBTUVURVInIHwgdHJhbnNsYXRlfX08L2Rpdj5cIixcbiAgICBzdHlsZXM6IFtcIi5jaGFydCB7ZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMDAlO30gIC5hbmFseXRpY3Mtcm93X19lbnRyeSB7ICAgICBjdXJzb3I6IHBvaW50ZXI7IH1cIl1cbn0pXG5leHBvcnQgY2xhc3MgQW5hbHl0aWNzR2VuZXJhdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgpXG4gICAgcmVwb3J0SWQ6IG51bWJlcjtcblxuICAgIEBJbnB1dCgpXG4gICAgcmVwb3J0UGFyYW1RdWVyeTogUmVwb3J0UXVlcnkgPSB1bmRlZmluZWQ7XG5cbiAgICBAT3V0cHV0KClcbiAgICBvblN1Y2Nlc3MgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBvbkVycm9yID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgcmVwb3J0czogQ2hhcnRbXTtcblxuICAgIHNob3dEZXRhaWxzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwdWJsaWMgYmFyQ2hhcnRPcHRpb25zOiBhbnkgPSB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgICAgeUF4ZXM6IFt7XG4gICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplOiAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB4QXhlczogW3tcbiAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhY2tlZDogdHJ1ZVxuICAgICAgICAgICAgfV1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyYW5zbGF0ZVNlcnZpY2U6IEFsZnJlc2NvVHJhbnNsYXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgYW5hbHl0aWNzU2VydmljZTogQW5hbHl0aWNzU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICAgICAgbG9nU2VydmljZS5pbmZvKCdBbmFseXRpY3NHZW5lcmF0b3JDb21wb25lbnQnKTtcbiAgICAgICAgaWYgKHRyYW5zbGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgICAgIHRyYW5zbGF0ZVNlcnZpY2UuYWRkVHJhbnNsYXRpb25Gb2xkZXIoJ25nMi1hY3Rpdml0aS1hbmFseXRpY3MnLCAnbm9kZV9tb2R1bGVzL25nMi1hY3Rpdml0aS1hbmFseXRpY3Mvc3JjJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcG9ydElkICYmIHRoaXMucmVwb3J0UGFyYW1RdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVJlcG9ydCh0aGlzLnJlcG9ydElkLCB0aGlzLnJlcG9ydFBhcmFtUXVlcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdlbmVyYXRlUmVwb3J0KHJlcG9ydElkLCByZXBvcnRQYXJhbVF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzU2VydmljZS5nZXRSZXBvcnRzQnlQYXJhbXMocmVwb3J0SWQsIHJlcG9ydFBhcmFtUXVlcnkpLnN1YnNjcmliZShcbiAgICAgICAgICAgIChyZXM6IENoYXJ0W10pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydHMgPSByZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3MuZW1pdChyZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvci5lbWl0KGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIHJlc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5yZXBvcnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgcmVmcmVzaChyZXBvcnQpOiB2b2lkIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIChNeSBndWVzcyksIGZvciBBbmd1bGFyIHRvIHJlY29nbml6ZSB0aGUgY2hhbmdlIGluIHRoZSBkYXRhc2V0XG4gICAgICAgICAqIGl0IGhhcyB0byBjaGFuZ2UgdGhlIGRhdGFzZXQgdmFyaWFibGUgZGlyZWN0bHksXG4gICAgICAgICAqIHNvIG9uZSB3YXkgYXJvdW5kIGl0LCBpcyB0byBjbG9uZSB0aGUgZGF0YSwgY2hhbmdlIGl0IGFuZCB0aGVuXG4gICAgICAgICAqIGFzc2lnbiBpdDtcbiAgICAgICAgICovXG4gICAgICAgIGxldCBjbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0KSk7XG4gICAgICAgIHJlcG9ydC5kYXRhc2V0cyA9IGNsb25lLmRhdGFzZXRzO1xuICAgIH1cblxuICAgIHRvZ2dsZURldGFpbHNUYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zaG93RGV0YWlscyA9ICF0aGlzLnNob3dEZXRhaWxzO1xuICAgIH1cblxuICAgIGlzU2hvd0RldGFpbHMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dEZXRhaWxzO1xuICAgIH1cbn1cbiJdfQ==
