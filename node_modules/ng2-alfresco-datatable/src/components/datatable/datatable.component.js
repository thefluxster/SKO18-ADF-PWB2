/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var core_1 = require("@angular/core");
var index_1 = require("../../data/index");
var DataTableComponent = (function () {
    function DataTableComponent() {
        this.multiselect = false;
        this.actions = false;
        this.rowClick = new core_1.EventEmitter();
        this.rowDblClick = new core_1.EventEmitter();
        this.showRowContextMenu = new core_1.EventEmitter();
        this.showRowActionsMenu = new core_1.EventEmitter();
        this.executeRowAction = new core_1.EventEmitter();
        this.isSelectAllChecked = false;
    }
    Object.defineProperty(DataTableComponent.prototype, "selectedRow", {
        get: function () {
            return this.data.selectedRow;
        },
        enumerable: true,
        configurable: true
    });
    DataTableComponent.prototype.ngOnInit = function () {
        if (!this.data) {
            this.data = new index_1.ObjectDataTableAdapter([], []);
        }
        if (componentHandler) {
            componentHandler.upgradeAllRegistered();
        }
    };
    DataTableComponent.prototype.onRowClick = function (row, e) {
        if (e) {
            e.preventDefault();
        }
        if (this.data) {
            this.data.selectedRow = row;
        }
        this.rowClick.emit({
            value: row,
            event: e
        });
    };
    DataTableComponent.prototype.onRowDblClick = function (row, e) {
        if (e) {
            e.preventDefault();
        }
        this.rowDblClick.emit({
            value: row,
            event: e
        });
    };
    DataTableComponent.prototype.onColumnHeaderClick = function (column) {
        if (column && column.sortable) {
            var current = this.data.getSorting();
            var newDirection = 'asc';
            if (current && column.key === current.key) {
                newDirection = current.direction === 'asc' ? 'desc' : 'asc';
            }
            this.data.setSorting(new index_1.DataSorting(column.key, newDirection));
        }
    };
    DataTableComponent.prototype.onSelectAllClick = function (e) {
        if (e) {
            e.preventDefault();
        }
        this.isSelectAllChecked = !this.isSelectAllChecked;
        if (this.multiselect) {
            var rows = this.data.getRows();
            if (rows && rows.length > 0) {
                for (var i = 0; i < rows.length; i++) {
                    rows[i].isSelected = this.isSelectAllChecked;
                }
            }
        }
    };
    DataTableComponent.prototype.onImageLoadingError = function (event) {
        if (event && this.fallbackThumbnail) {
            var element = event.target;
            element.src = this.fallbackThumbnail;
        }
    };
    DataTableComponent.prototype.isIconValue = function (row, col) {
        if (row && col) {
            var value = row.getValue(col.key);
            return value && value.startsWith('material-icons://');
        }
        return false;
    };
    DataTableComponent.prototype.asIconValue = function (row, col) {
        if (this.isIconValue(row, col)) {
            var value = row.getValue(col.key) || '';
            return value.replace('material-icons://', '');
        }
        return null;
    };
    DataTableComponent.prototype.iconAltTextKey = function (value) {
        return 'ICONS.' + value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '');
    };
    DataTableComponent.prototype.isColumnSorted = function (col, direction) {
        if (col && direction) {
            var sorting = this.data.getSorting();
            return sorting && sorting.key === col.key && sorting.direction === direction;
        }
        return false;
    };
    DataTableComponent.prototype.getContextMenuActions = function (row, col) {
        var args = { row: row, col: col, actions: [] };
        this.showRowContextMenu.emit({ args: args });
        return args.actions;
    };
    DataTableComponent.prototype.getRowActions = function (row, col) {
        var args = { row: row, col: col, actions: [] };
        this.showRowActionsMenu.emit({ args: args });
        return args.actions;
    };
    DataTableComponent.prototype.onExecuteRowAction = function (row, action) {
        var args = { row: row, action: action };
        this.executeRowAction.emit({ args: args });
    };
    return DataTableComponent;
}());
__decorate([
    core_1.Input(),
    __metadata("design:type", Object)
], DataTableComponent.prototype, "data", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTableComponent.prototype, "multiselect", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", Boolean)
], DataTableComponent.prototype, "actions", void 0);
__decorate([
    core_1.Input(),
    __metadata("design:type", String)
], DataTableComponent.prototype, "fallbackThumbnail", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTableComponent.prototype, "rowClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTableComponent.prototype, "rowDblClick", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTableComponent.prototype, "showRowContextMenu", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTableComponent.prototype, "showRowActionsMenu", void 0);
__decorate([
    core_1.Output(),
    __metadata("design:type", core_1.EventEmitter)
], DataTableComponent.prototype, "executeRowAction", void 0);
DataTableComponent = __decorate([
    core_1.Component({
        moduleId: module.id,
        selector: 'alfresco-datatable',
        styles: [":host .full-width { width: 100%; }  :host .icon-cell {     font-size: 24px;     cursor: default; }  :host .image-cell {     width: 24px;     height: 24px;     cursor: default; }  :host .data-cell {     cursor: default; } :host .cell-value {}  :host .column-header {     cursor: pointer;     user-select: none;     -webkit-user-select: none;   /* Chrome/Safari/Opera */     -moz-user-select: none;      /* Firefox */     -ms-user-select: none;       /* IE/Edge */     -webkit-touch-callout: none; /* iOS Safari */ }  /* Empty folder */  :host .no-content-container {     padding: 0 !important; }  :host .no-content-container > img {     width: 100%; }  :host .ellipsis-cell > div {     position: relative;     overflow: hidden;     /*height: 1em;*/ }   /* visible content */ :host .ellipsis-cell > div > span {     display: block;     position: absolute;     max-width: 100%;     white-space: nowrap;     overflow: hidden;     text-overflow: ellipsis;     line-height: 1em;\t\t/* for vertical align of text */ }   /* cell stretching content */ :host .ellipsis-cell > div:after {     content: attr(title);     overflow: hidden;     height: 0;     display: block; }   /* Utils */  :host .non-selectable {     user-select: none;     -webkit-user-select: none;   /* Chrome/Safari/Opera */     -moz-user-select: none;      /* Firefox */     -ms-user-select: none;       /* IE/Edge */     -webkit-touch-callout: none; /* iOS Safari */ }  :host .sr-only {     position: absolute;     width: 1px;     height: 1px;     padding: 0;     margin: -1px;     overflow: hidden;     clip: rect(0,0,0,0);     border: 0; }  .hidden {     display: none; }  /* small desktop */ @media all and (max-width: 1200px) {}  /* tablet */ @media all and (max-width: 1024px) {}  /* mobile phone */ @media all and (max-width: 768px) {     .desktop-only {         display: none;     } }  @media (max-device-width: 768px){     .desktop-only {         display: none;     } }  .mdl-data-table-fix-firefox {     border-collapse: unset;     border-spacing: 0; }  .alfresco-datatable__row:focus {     outline-offset: -4px; }  .alfresco-datatable__row--selected {     color: rgb(68,138,255); }"],
        template: "<table     *ngIf=\"data\"     class=\"mdl-data-table mdl-js-data-table full-width mdl-data-table-fix-firefox\">     <thead>     <tr>         <!-- Columns -->         <th *ngIf=\"multiselect\">             <label                 class=\"mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect mdl-data-table__select\"                 [class.is-checked]=\"isSelectAllChecked\"                 for=\"table-header\"                 (click)=\"onSelectAllClick($event)\">                 <input type=\"checkbox\" id=\"table-header\" class=\"mdl-checkbox__input\" />             </label>         </th>         <th class=\"mdl-data-table__cell--non-numeric non-selectable {{col.cssClass}}\"             *ngFor=\"let col of data.getColumns()\"             [attr.data-automation-id]=\"'auto_id_' + col.key\"             [class.column-header]=\"col.title\"             [class.mdl-data-table__header--sorted-ascending]=\"isColumnSorted(col, 'asc')\"             [class.mdl-data-table__header--sorted-descending]=\"isColumnSorted(col, 'desc')\"             (click)=\"onColumnHeaderClick(col)\">             <span *ngIf=\"col.srTitle\" class=\"sr-only\">{{col.srTitle}}</span>             <span *ngIf=\"col.title\">{{col.title}}</span>         </th>         <!-- Actions -->         <th *ngIf=\"actions\">             <span class=\"sr-only\">Actions</span>         </th>     </tr>     </thead>     <tbody>      <tr *ngFor=\"let row of data.getRows(); let idx = index\" tabindex=\"0\"         class=\"alfresco-datatable__row\"         [class.alfresco-datatable__row--selected]=\"selectedRow === row\">         <td *ngIf=\"multiselect\">             <label                 class=\"mdl-checkbox mdl-js-checkbox mdl-js-ripple-effect mdl-data-table__select\"                 [attr.for]=\"'row[' + idx + ']'\"                 [class.is-checked]=\"row.isSelected\">                 <input type=\"checkbox\" [attr.id]=\"'row[' + idx + ']'\" class=\"mdl-checkbox__input\" [(ngModel)]=\"row.isSelected\" />             </label>         </td>         <td *ngFor=\"let col of data.getColumns()\" [ngSwitch]=\"col.type\"             class=\"mdl-data-table__cell--non-numeric non-selectable data-cell {{col.cssClass}}\"             (click)=\"onRowClick(row, $event)\"             (dblclick)=\"onRowDblClick(row, $event)\"             [context-menu]=\"getContextMenuActions(row, col)\">             <div *ngIf=\"!col.template\">                 <div *ngSwitchCase=\"'image'\" class=\"cell-value\">                     <i *ngIf=\"isIconValue(row, col)\" class=\"material-icons icon-cell\">{{asIconValue(row, col)}}</i>                     <img *ngIf=\"!isIconValue(row, col)\"                         class=\"image-cell\"                         alt=\"{{iconAltTextKey(data.getValue(row, col))|translate}}\"                         src=\"{{data.getValue(row, col)}}\"                         (error)=\"onImageLoadingError($event)\">                 </div>                 <div *ngSwitchCase=\"'date'\" class=\"cell-value\" [attr.data-automation-id]=\"'date_' + data.getValue(row, col)\">                     {{data.getValue(row, col)}}                 </div>                 <div *ngSwitchCase=\"'text'\" class=\"cell-value\" [attr.data-automation-id]=\"'text_' + data.getValue(row, col)\">                     {{data.getValue(row, col)}}                 </div>                 <span *ngSwitchDefault class=\"cell-value\">                 <!-- empty cell for unknown column type -->                 </span>             </div>             <div *ngIf=\"col.template\">                 <template ngFor [ngForOf]=\"[{ data: data, row: row, col: col }]\" [ngForTemplate]=\"col.template\"></template>             </div>         </td>          <td *ngIf=\"actions\">             <!-- action menu -->             <button [id]=\"'action_menu_' + idx\" alfresco-mdl-button class=\"mdl-button--icon\" [attr.data-automation-id]=\"actions_menu\">                 <i class=\"material-icons\">more_vert</i>             </button>             <ul alfresco-mdl-menu class=\"mdl-menu--bottom-right\"                 [attr.for]=\"'action_menu_' + idx\">                 <li class=\"mdl-menu__item\"                     [attr.data-automation-id]=\"action.title\"                     *ngFor=\"let action of getRowActions(row)\"                     (click)=\"onExecuteRowAction(row, action)\">                     {{action.title}}                 </li>             </ul>         </td>      </tr>     <tr *ngIf=\"data.getRows().length === 0\">         <td class=\"mdl-data-table__cell--non-numeric no-content-container\"             [attr.colspan]=\"1 + data.getColumns().length\">             <template *ngIf=\"noContentTemplate\"                       ngFor [ngForOf]=\"[data]\"                       [ngForTemplate]=\"noContentTemplate\">             </template>         </td>     </tr>     </tbody> </table>"
    })
], DataTableComponent);
exports.DataTableComponent = DataTableComponent;

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbXBvbmVudHMvZGF0YXRhYmxlL2RhdGF0YWJsZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHOzs7Ozs7Ozs7OztBQUVILHNDQUE0RjtBQUM1RiwwQ0FPMEI7QUFVMUIsSUFBYSxrQkFBa0I7SUFOL0I7UUFZSSxnQkFBVyxHQUFZLEtBQUssQ0FBQztRQUc3QixZQUFPLEdBQVksS0FBSyxDQUFDO1FBTXpCLGFBQVEsR0FBK0IsSUFBSSxtQkFBWSxFQUFnQixDQUFDO1FBR3hFLGdCQUFXLEdBQStCLElBQUksbUJBQVksRUFBZ0IsQ0FBQztRQUczRSx1QkFBa0IsR0FBc0IsSUFBSSxtQkFBWSxFQUFFLENBQUM7UUFHM0QsdUJBQWtCLEdBQXNCLElBQUksbUJBQVksRUFBRSxDQUFDO1FBRzNELHFCQUFnQixHQUFzQixJQUFJLG1CQUFZLEVBQUUsQ0FBQztRQUd6RCx1QkFBa0IsR0FBWSxLQUFLLENBQUM7SUFnSXhDLENBQUM7SUE5SEcsc0JBQUksMkNBQVc7YUFBZjtZQUNJLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNqQyxDQUFDOzs7T0FBQTtJQUVELHFDQUFRLEdBQVI7UUFDSSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLDhCQUFzQixDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNuRCxDQUFDO1FBR0QsRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1lBQ25CLGdCQUFnQixDQUFDLG9CQUFvQixFQUFFLENBQUM7UUFDNUMsQ0FBQztJQUNMLENBQUM7SUFFRCx1Q0FBVSxHQUFWLFVBQVcsR0FBWSxFQUFFLENBQVM7UUFDOUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNKLENBQUMsQ0FBQyxjQUFjLEVB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VyxtQkFBWTs4REFBMkI7QUFHM0Q7SUFEQyxhQUFNLEVBQUU7OEJBQ1csbUJBQVk7OERBQTJCO0FBRzNEO0lBREMsYUFBTSxFQUFFOzhCQUNTLG1CQUFZOzREQUEyQjtBQTNCaEQsa0JBQWtCO0lBTjlCLGdCQUFTLENBQUM7UUFDUCxRQUFRLEVBQUUsTUFBTSxDQUFDLEVBQUU7UUFDbkIsUUFBUSxFQUFFLG9CQUFvQjtRQUM5QixNQUFNLEVBQUUsQ0FBQywwbUVBQTBtRSxDQUFDO1FBQ3BuRSxRQUFRLEVBQUUscXZKQUFxdko7S0FDbHdKLENBQUM7R0FDVyxrQkFBa0IsQ0E4SjlCO0FBOUpZLGdEQUFrQiIsImZpbGUiOiJjb21wb25lbnRzL2RhdGF0YWJsZS9kYXRhdGFibGUuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgRGF0YVRhYmxlQWRhcHRlcixcbiAgICBEYXRhUm93LFxuICAgIERhdGFDb2x1bW4sXG4gICAgRGF0YVNvcnRpbmcsXG4gICAgRGF0YVJvd0V2ZW50LFxuICAgIE9iamVjdERhdGFUYWJsZUFkYXB0ZXJcbn0gZnJvbSAnLi4vLi4vZGF0YS9pbmRleCc7XG5cbmRlY2xhcmUgdmFyIGNvbXBvbmVudEhhbmRsZXI7XG5cbkBDb21wb25lbnQoe1xuICAgIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gICAgc2VsZWN0b3I6ICdhbGZyZXNjby1kYXRhdGFibGUnLFxuICAgIHN0eWxlczogW1wiOmhvc3QgLmZ1bGwtd2lkdGggeyB3aWR0aDogMTAwJTsgfSAgOmhvc3QgLmljb24tY2VsbCB7ICAgICBmb250LXNpemU6IDI0cHg7ICAgICBjdXJzb3I6IGRlZmF1bHQ7IH0gIDpob3N0IC5pbWFnZS1jZWxsIHsgICAgIHdpZHRoOiAyNHB4OyAgICAgaGVpZ2h0OiAyNHB4OyAgICAgY3Vyc29yOiBkZWZhdWx0OyB9ICA6aG9zdCAuZGF0YS1jZWxsIHsgICAgIGN1cnNvcjogZGVmYXVsdDsgfSA6aG9zdCAuY2VsbC12YWx1ZSB7fSAgOmhvc3QgLmNvbHVtbi1oZWFkZXIgeyAgICAgY3Vyc29yOiBwb2ludGVyOyAgICAgdXNlci1zZWxlY3Q6IG5vbmU7ICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOyAgIC8qIENocm9tZS9TYWZhcmkvT3BlcmEgKi8gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7ICAgICAgLyogRmlyZWZveCAqLyAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lOyAgICAgICAvKiBJRS9FZGdlICovICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7IC8qIGlPUyBTYWZhcmkgKi8gfSAgLyogRW1wdHkgZm9sZGVyICovICA6aG9zdCAubm8tY29udGVudC1jb250YWluZXIgeyAgICAgcGFkZGluZzogMCAhaW1wb3J0YW50OyB9ICA6aG9zdCAubm8tY29udGVudC1jb250YWluZXIgPiBpbWcgeyAgICAgd2lkdGg6IDEwMCU7IH0gIDpob3N0IC5lbGxpcHNpcy1jZWxsID4gZGl2IHsgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgICAgIG92ZXJmbG93OiBoaWRkZW47ICAgICAvKmhlaWdodDogMWVtOyovIH0gICAvKiB2aXNpYmxlIGNvbnRlbnQgKi8gOmhvc3QgLmVsbGlwc2lzLWNlbGwgPiBkaXYgPiBzcGFuIHsgICAgIGRpc3BsYXk6IGJsb2NrOyAgICAgcG9zaXRpb246IGFic29sdXRlOyAgICAgbWF4LXdpZHRoOiAxMDAlOyAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgICAgIG92ZXJmbG93OiBoaWRkZW47ICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsgICAgIGxpbmUtaGVpZ2h0OiAxZW07XFx0XFx0LyogZm9yIHZlcnRpY2FsIGFsaWduIG9mIHRleHQgKi8gfSAgIC8qIGNlbGwgc3RyZXRjaGluZyBjb250ZW50ICovIDpob3N0IC5lbGxpcHNpcy1jZWxsID4gZGl2OmFmdGVyIHsgICAgIGNvbnRlbnQ6IGF0dHIodGl0bGUpOyAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgICAgIGhlaWdodDogMDsgICAgIGRpc3BsYXk6IGJsb2NrOyB9ICAgLyogVXRpbHMgKi8gIDpob3N0IC5ub24tc2VsZWN0YWJsZSB7ICAgICB1c2VyLXNlbGVjdDogbm9uZTsgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7ICAgLyogQ2hyb21lL1NhZmFyaS9PcGVyYSAqLyAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsgICAgICAvKiBGaXJlZm94ICovICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7ICAgICAgIC8qIElFL0VkZ2UgKi8gICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqLyB9ICA6aG9zdCAuc3Itb25seSB7ICAgICBwb3NpdGlvbjogYWJzb2x1dGU7ICAgICB3aWR0aDogMXB4OyAgICAgaGVpZ2h0OiAxcHg7ICAgICBwYWRkaW5nOiAwOyAgICAgbWFyZ2luOiAtMXB4OyAgICAgb3ZlcmZsb3c6IGhpZGRlbjsgICAgIGNsaXA6IHJlY3QoMCwwLDAsMCk7ICAgICBib3JkZXI6IDA7IH0gIC5oaWRkZW4geyAgICAgZGlzcGxheTogbm9uZTsgfSAgLyogc21hbGwgZGVza3RvcCAqLyBAbWVkaWEgYWxsIGFuZCAobWF4LXdpZHRoOiAxMjAwcHgpIHt9ICAvKiB0YWJsZXQgKi8gQG1lZGlhIGFsbCBhbmQgKG1heC13aWR0aDogMTAyNHB4KSB7fSAgLyogbW9iaWxlIHBob25lICovIEBtZWRpYSBhbGwgYW5kIChtYXgtd2lkdGg6IDc2OHB4KSB7ICAgICAuZGVza3RvcC1vbmx5IHsgICAgICAgICBkaXNwbGF5OiBub25lOyAgICAgfSB9ICBAbWVkaWEgKG1heC1kZXZpY2Utd2lkdGg6IDc2OHB4KXsgICAgIC5kZXNrdG9wLW9ubHkgeyAgICAgICAgIGRpc3BsYXk6IG5vbmU7ICAgICB9IH0gIC5tZGwtZGF0YS10YWJsZS1maXgtZmlyZWZveCB7ICAgICBib3JkZXItY29sbGFwc2U6IHVuc2V0OyAgICAgYm9yZGVyLXNwYWNpbmc6IDA7IH0gIC5hbGZyZXNjby1kYXRhdGFibGVfX3Jvdzpmb2N1cyB7ICAgICBvdXRsaW5lLW9mZnNldDogLTRweDsgfSAgLmFsZnJlc2NvLWRhdGF0YWJsZV9fcm93LS1zZWxlY3RlZCB7ICAgICBjb2xvcjogcmdiKDY4LDEzOCwyNTUpOyB9XCJdLFxuICAgIHRlbXBsYXRlOiBcIjx0YWJsZSAgICAgKm5nSWY9XFxcImRhdGFcXFwiICAgICBjbGFzcz1cXFwibWRsLWRhdGEtdGFibGUgbWRsLWpzLWRhdGEtdGFibGUgZnVsbC13aWR0aCBtZGwtZGF0YS10YWJsZS1maXgtZmlyZWZveFxcXCI+ICAgICA8dGhlYWQ+ICAgICA8dHI+ICAgICAgICAgPCEtLSBDb2x1bW5zIC0tPiAgICAgICAgIDx0aCAqbmdJZj1cXFwibXVsdGlzZWxlY3RcXFwiPiAgICAgICAgICAgICA8bGFiZWwgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJtZGwtY2hlY2tib3ggbWRsLWpzLWNoZWNrYm94IG1kbC1qcy1yaXBwbGUtZWZmZWN0IG1kbC1kYXRhLXRhYmxlX19zZWxlY3RcXFwiICAgICAgICAgICAgICAgICBbY2xhc3MuaXMtY2hlY2tlZF09XFxcImlzU2VsZWN0QWxsQ2hlY2tlZFxcXCIgICAgICAgICAgICAgICAgIGZvcj1cXFwidGFibGUtaGVhZGVyXFxcIiAgICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwib25TZWxlY3RBbGxDbGljaygkZXZlbnQpXFxcIj4gICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcInRhYmxlLWhlYWRlclxcXCIgY2xhc3M9XFxcIm1kbC1jaGVja2JveF9faW5wdXRcXFwiIC8+ICAgICAgICAgICAgIDwvbGFiZWw+ICAgICAgICAgPC90aD4gICAgICAgICA8dGggY2xhc3M9XFxcIm1kbC1kYXRhLXRhYmxlX19jZWxsLS1ub24tbnVtZXJpYyBub24tc2VsZWN0YWJsZSB7e2NvbC5jc3NDbGFzc319XFxcIiAgICAgICAgICAgICAqbmdGb3I9XFxcImxldCBjb2wgb2YgZGF0YS5nZXRDb2x1bW5zKClcXFwiICAgICAgICAgICAgIFthdHRyLmRhdGEtYXV0b21hdGlvbi1pZF09XFxcIidhdXRvX2lkXycgKyBjb2wua2V5XFxcIiAgICAgICAgICAgICBbY2xhc3MuY29sdW1uLWhlYWRlcl09XFxcImNvbC50aXRsZVxcXCIgICAgICAgICAgICAgW2NsYXNzLm1kbC1kYXRhLXRhYmxlX19oZWFkZXItLXNvcnRlZC1hc2NlbmRpbmddPVxcXCJpc0NvbHVtblNvcnRlZChjb2wsICdhc2MnKVxcXCIgICAgICAgICAgICAgW2NsYXNzLm1kbC1kYXRhLXRhYmxlX19oZWFkZXItLXNvcnRlZC1kZXNjZW5kaW5nXT1cXFwiaXNDb2x1bW5Tb3J0ZWQoY29sLCAnZGVzYycpXFxcIiAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkNvbHVtbkhlYWRlckNsaWNrKGNvbClcXFwiPiAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiY29sLnNyVGl0bGVcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj57e2NvbC5zclRpdGxlfX08L3NwYW4+ICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJjb2wudGl0bGVcXFwiPnt7Y29sLnRpdGxlfX08L3NwYW4+ICAgICAgICAgPC90aD4gICAgICAgICA8IS0tIEFjdGlvbnMgLS0+ICAgICAgICAgPHRoICpuZ0lmPVxcXCJhY3Rpb25zXFxcIj4gICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPkFjdGlvbnM8L3NwYW4+ICAgICAgICAgPC90aD4gICAgIDwvdHI+ICAgICA8L3RoZWFkPiAgICAgPHRib2R5PiAgICAgIDx0ciAqbmdGb3I9XFxcImxldCByb3cgb2YgZGF0YS5nZXRSb3dzKCk7IGxldCBpZHggPSBpbmRleFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiICAgICAgICAgY2xhc3M9XFxcImFsZnJlc2NvLWRhdGF0YWJsZV9fcm93XFxcIiAgICAgICAgIFtjbGFzcy5hbGZyZXNjby1kYXRhdGFibGVfX3Jvdy0tc2VsZWN0ZWRdPVxcXCJzZWxlY3RlZFJvdyA9PT0gcm93XFxcIj4gICAgICAgICA8dGQgKm5nSWY9XFxcIm11bHRpc2VsZWN0XFxcIj4gICAgICAgICAgICAgPGxhYmVsICAgICAgICAgICAgICAgICBjbGFzcz1cXFwibWRsLWNoZWNrYm94IG1kbC1qcy1jaGVja2JveCBtZGwtanMtcmlwcGxlLWVmZmVjdCBtZGwtZGF0YS10YWJsZV9fc2VsZWN0XFxcIiAgICAgICAgICAgICAgICAgW2F0dHIuZm9yXT1cXFwiJ3Jvd1snICsgaWR4ICsgJ10nXFxcIiAgICAgICAgICAgICAgICAgW2NsYXNzLmlzLWNoZWNrZWRdPVxcXCJyb3cuaXNTZWxlY3RlZFxcXCI+ICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFthdHRyLmlkXT1cXFwiJ3Jvd1snICsgaWR4ICsgJ10nXFxcIiBjbGFzcz1cXFwibWRsLWNoZWNrYm94X19pbnB1dFxcXCIgWyhuZ01vZGVsKV09XFxcInJvdy5pc1NlbGVjdGVkXFxcIiAvPiAgICAgICAgICAgICA8L2xhYmVsPiAgICAgICAgIDwvdGQ+ICAgICAgICAgPHRkICpuZ0Zvcj1cXFwibGV0IGNvbCBvZiBkYXRhLmdldENvbHVtbnMoKVxcXCIgW25nU3dpdGNoXT1cXFwiY29sLnR5cGVcXFwiICAgICAgICAgICAgIGNsYXNzPVxcXCJtZGwtZGF0YS10YWJsZV9fY2VsbC0tbm9uLW51bWVyaWMgbm9uLXNlbGVjdGFibGUgZGF0YS1jZWxsIHt7Y29sLmNzc0NsYXNzfX1cXFwiICAgICAgICAgICAgIChjbGljayk9XFxcIm9uUm93Q2xpY2socm93LCAkZXZlbnQpXFxcIiAgICAgICAgICAgICAoZGJsY2xpY2spPVxcXCJvblJvd0RibENsaWNrKHJvdywgJGV2ZW50KVxcXCIgICAgICAgICAgICAgW2NvbnRleHQtbWVudV09XFxcImdldENvbnRleHRNZW51QWN0aW9ucyhyb3csIGNvbClcXFwiPiAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCIhY29sLnRlbXBsYXRlXFxcIj4gICAgICAgICAgICAgICAgIDxkaXYgKm5nU3dpdGNoQ2FzZT1cXFwiJ2ltYWdlJ1xcXCIgY2xhc3M9XFxcImNlbGwtdmFsdWVcXFwiPiAgICAgICAgICAgICAgICAgICAgIDxpICpuZ0lmPVxcXCJpc0ljb25WYWx1ZShyb3csIGNvbClcXFwiIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29ucyBpY29uLWNlbGxcXFwiPnt7YXNJY29uVmFsdWUocm93LCBjb2wpfX08L2k+ICAgICAgICAgICAgICAgICAgICAgPGltZyAqbmdJZj1cXFwiIWlzSWNvblZhbHVlKHJvdywgY29sKVxcXCIgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XFxcImltYWdlLWNlbGxcXFwiICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD1cXFwie3tpY29uQWx0VGV4dEtleShkYXRhLmdldFZhbHVlKHJvdywgY29sKSl8dHJhbnNsYXRlfX1cXFwiICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz1cXFwie3tkYXRhLmdldFZhbHVlKHJvdywgY29sKX19XFxcIiAgICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3IpPVxcXCJvbkltYWdlTG9hZGluZ0Vycm9yKCRldmVudClcXFwiPiAgICAgICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgICAgICAgICA8ZGl2ICpuZ1N3aXRjaENhc2U9XFxcIidkYXRlJ1xcXCIgY2xhc3M9XFxcImNlbGwtdmFsdWVcXFwiIFthdHRyLmRhdGEtYXV0b21hdGlvbi1pZF09XFxcIidkYXRlXycgKyBkYXRhLmdldFZhbHVlKHJvdywgY29sKVxcXCI+ICAgICAgICAgICAgICAgICAgICAge3tkYXRhLmdldFZhbHVlKHJvdywgY29sKX19ICAgICAgICAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgIDxkaXYgKm5nU3dpdGNoQ2FzZT1cXFwiJ3RleHQnXFxcIiBjbGFzcz1cXFwiY2VsbC12YWx1ZVxcXCIgW2F0dHIuZGF0YS1hdXRvbWF0aW9uLWlkXT1cXFwiJ3RleHRfJyArIGRhdGEuZ2V0VmFsdWUocm93LCBjb2wpXFxcIj4gICAgICAgICAgICAgICAgICAgICB7e2RhdGEuZ2V0VmFsdWUocm93LCBjb2wpfX0gICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoRGVmYXVsdCBjbGFzcz1cXFwiY2VsbC12YWx1ZVxcXCI+ICAgICAgICAgICAgICAgICA8IS0tIGVtcHR5IGNlbGwgZm9yIHVua25vd24gY29sdW1uIHR5cGUgLS0+ICAgICAgICAgICAgICAgICA8L3NwYW4+ICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVxcXCJjb2wudGVtcGxhdGVcXFwiPiAgICAgICAgICAgICAgICAgPHRlbXBsYXRlIG5nRm9yIFtuZ0Zvck9mXT1cXFwiW3sgZGF0YTogZGF0YSwgcm93OiByb3csIGNvbDogY29sIH1dXFxcIiBbbmdGb3JUZW1wbGF0ZV09XFxcImNvbC50ZW1wbGF0ZVxcXCI+PC90ZW1wbGF0ZT4gICAgICAgICAgICAgPC9kaXY+ICAgICAgICAgPC90ZD4gICAgICAgICAgPHRkICpuZ0lmPVxcXCJhY3Rpb25zXFxcIj4gICAgICAgICAgICAgPCEtLSBhY3Rpb24gbWVudSAtLT4gICAgICAgICAgICAgPGJ1dHRvbiBbaWRdPVxcXCInYWN0aW9uX21lbnVfJyArIGlkeFxcXCIgYWxmcmVzY28tbWRsLWJ1dHRvbiBjbGFzcz1cXFwibWRsLWJ1dHRvbi0taWNvblxcXCIgW2F0dHIuZGF0YS1hdXRvbWF0aW9uLWlkXT1cXFwiYWN0aW9uc19tZW51XFxcIj4gICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29uc1xcXCI+bW9yZV92ZXJ0PC9pPiAgICAgICAgICAgICA8L2J1dHRvbj4gICAgICAgICAgICAgPHVsIGFsZnJlc2NvLW1kbC1tZW51IGNsYXNzPVxcXCJtZGwtbWVudS0tYm90dG9tLXJpZ2h0XFxcIiAgICAgICAgICAgICAgICAgW2F0dHIuZm9yXT1cXFwiJ2FjdGlvbl9tZW51XycgKyBpZHhcXFwiPiAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVxcXCJtZGwtbWVudV9faXRlbVxcXCIgICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWF1dG9tYXRpb24taWRdPVxcXCJhY3Rpb24udGl0bGVcXFwiICAgICAgICAgICAgICAgICAgICAgKm5nRm9yPVxcXCJsZXQgYWN0aW9uIG9mIGdldFJvd0FjdGlvbnMocm93KVxcXCIgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVxcXCJvbkV4ZWN1dGVSb3dBY3Rpb24ocm93LCBhY3Rpb24pXFxcIj4gICAgICAgICAgICAgICAgICAgICB7e2FjdGlvbi50aXRsZX19ICAgICAgICAgICAgICAgICA8L2xpPiAgICAgICAgICAgICA8L3VsPiAgICAgICAgIDwvdGQ+ICAgICAgPC90cj4gICAgIDx0ciAqbmdJZj1cXFwiZGF0YS5nZXRSb3dzKCkubGVuZ3RoID09PSAwXFxcIj4gICAgICAgICA8dGQgY2xhc3M9XFxcIm1kbC1kYXRhLXRhYmxlX19jZWxsLS1ub24tbnVtZXJpYyBuby1jb250ZW50LWNvbnRhaW5lclxcXCIgICAgICAgICAgICAgW2F0dHIuY29sc3Bhbl09XFxcIjEgKyBkYXRhLmdldENvbHVtbnMoKS5sZW5ndGhcXFwiPiAgICAgICAgICAgICA8dGVtcGxhdGUgKm5nSWY9XFxcIm5vQ29udGVudFRlbXBsYXRlXFxcIiAgICAgICAgICAgICAgICAgICAgICAgbmdGb3IgW25nRm9yT2ZdPVxcXCJbZGF0YV1cXFwiICAgICAgICAgICAgICAgICAgICAgICBbbmdGb3JUZW1wbGF0ZV09XFxcIm5vQ29udGVudFRlbXBsYXRlXFxcIj4gICAgICAgICAgICAgPC90ZW1wbGF0ZT4gICAgICAgICA8L3RkPiAgICAgPC90cj4gICAgIDwvdGJvZHk+IDwvdGFibGU+XCJcbn0pXG5leHBvcnQgY2xhc3MgRGF0YVRhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpXG4gICAgZGF0YTogRGF0YVRhYmxlQWRhcHRlcjtcblxuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBmYWxsYmFja1RodW1ibmFpbDogc3RyaW5nO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcm93Q2xpY2s6IEV2ZW50RW1pdHRlcjxEYXRhUm93RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRhUm93RXZlbnQ+KCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICByb3dEYmxDbGljazogRXZlbnRFbWl0dGVyPERhdGFSb3dFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGFSb3dFdmVudD4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHNob3dSb3dDb250ZXh0TWVudTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzaG93Um93QWN0aW9uc01lbnU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgZXhlY3V0ZVJvd0FjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBub0NvbnRlbnRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBpc1NlbGVjdEFsbENoZWNrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGdldCBzZWxlY3RlZFJvdygpOiBEYXRhUm93IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zZWxlY3RlZFJvdztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBPYmplY3REYXRhVGFibGVBZGFwdGVyKFtdLCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBNREwgaXNzdWVzIHdpdGggZHluYW1pYyBjb21wb25lbnRzXG4gICAgICAgIGlmIChjb21wb25lbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wb25lbnRIYW5kbGVyLnVwZ3JhZGVBbGxSZWdpc3RlcmVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblJvd0NsaWNrKHJvdzogRGF0YVJvdywgZT86IEV2ZW50KSB7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2VsZWN0ZWRSb3cgPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJvd0NsaWNrLmVtaXQoe1xuICAgICAgICAgICAgdmFsdWU6IHJvdyxcbiAgICAgICAgICAgIGV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9uUm93RGJsQ2xpY2socm93OiBEYXRhUm93LCBlPzogRXZlbnQpIHtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucm93RGJsQ2xpY2suZW1pdCh7XG4gICAgICAgICAgICB2YWx1ZTogcm93LFxuICAgICAgICAgICAgZXZlbnQ6IGVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb25Db2x1bW5IZWFkZXJDbGljayhjb2x1bW46IERhdGFDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uc29ydGFibGUpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5kYXRhLmdldFNvcnRpbmcoKTtcbiAgICAgICAgICAgIGxldCBuZXdEaXJlY3Rpb24gPSAnYXNjJztcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGNvbHVtbi5rZXkgPT09IGN1cnJlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgbmV3RGlyZWN0aW9uID0gY3VycmVudC5kaXJlY3Rpb24gPT09ICdhc2MnID8gJ2Rlc2MnIDogJ2FzYyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0U29ydGluZyhuZXcgRGF0YVNvcnRpbmcoY29sdW1uLmtleSwgbmV3RGlyZWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvblNlbGVjdEFsbENsaWNrKGU/OiBFdmVudCkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc1NlbGVjdEFsbENoZWNrZWQgPSAhdGhpcy5pc1NlbGVjdEFsbENoZWNrZWQ7XG5cbiAgICAgICAgaWYgKHRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIGxldCByb3dzID0gdGhpcy5kYXRhLmdldFJvd3MoKTtcbiAgICAgICAgICAgIGlmIChyb3dzICYmIHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByb3dzW2ldLmlzU2VsZWN0ZWQgPSB0aGlzLmlzU2VsZWN0QWxsQ2hlY2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogbGVmdCBmb3IgcmVmZXJlbmNlLCB3aWxsIGJlIHJlbW92ZWQgZHVyaW5nIGZ1dHVyZSByZXZpc2lvbnNcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmdldFJvd3MoKVsxXS5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkltYWdlTG9hZGluZ0Vycm9yKGV2ZW50OiBFdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQgJiYgdGhpcy5mYWxsYmFja1RodW1ibmFpbCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSA8YW55PiBldmVudC50YXJnZXQ7XG4gICAgICAgICAgICBlbGVtZW50LnNyYyA9IHRoaXMuZmFsbGJhY2tUaHVtYm5haWw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0ljb25WYWx1ZShyb3c6IERhdGFSb3csIGNvbDogRGF0YUNvbHVtbikge1xuICAgICAgICBpZiAocm93ICYmIGNvbCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbC5rZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnN0YXJ0c1dpdGgoJ21hdGVyaWFsLWljb25zOi8vJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFzSWNvblZhbHVlKHJvdzogRGF0YVJvdywgY29sOiBEYXRhQ29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSWNvblZhbHVlKHJvdywgY29sKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbC5rZXkpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoJ21hdGVyaWFsLWljb25zOi8vJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGljb25BbHRUZXh0S2V5KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICdJQ09OUy4nICsgdmFsdWUuc3Vic3RyaW5nKHZhbHVlLmxhc3RJbmRleE9mKCcvJykgKyAxKS5yZXBsYWNlKC9cXC5bYS16XSsvLCAnJyk7XG4gICAgfVxuXG4gICAgaXNDb2x1bW5Tb3J0ZWQoY29sOiBEYXRhQ29sdW1uLCBkaXJlY3Rpb246IHN0cmluZykge1xuICAgICAgICBpZiAoY29sICYmIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgbGV0IHNvcnRpbmcgPSB0aGlzLmRhdGEuZ2V0U29ydGluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRpbmcgJiYgc29ydGluZy5rZXkgPT09IGNvbC5rZXkgJiYgc29ydGluZy5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0Q29udGV4dE1lbnVBY3Rpb25zKHJvdzogRGF0YVJvdywgY29sOiBEYXRhQ29sdW1uKSB7XG4gICAgICAgIGxldCBhcmdzID0geyByb3c6IHJvdywgY29sOiBjb2wsIGFjdGlvbnM6IFtdIH07XG4gICAgICAgIHRoaXMuc2hvd1Jvd0NvbnRleHRNZW51LmVtaXQoeyBhcmdzOiBhcmdzIH0pO1xuICAgICAgICByZXR1cm4gYXJncy5hY3Rpb25zO1xuICAgIH1cblxuICAgIGdldFJvd0FjdGlvbnMocm93OiBEYXRhUm93LCBjb2w6IERhdGFDb2x1bW4pIHtcbiAgICAgICAgbGV0IGFyZ3MgPSB7IHJvdzogcm93LCBjb2w6IGNvbCwgYWN0aW9uczogW10gfTtcbiAgICAgICAgdGhpcy5zaG93Um93QWN0aW9uc01lbnUuZW1pdCh7IGFyZ3M6IGFyZ3MgfSk7XG4gICAgICAgIHJldHVybiBhcmdzLmFjdGlvbnM7XG4gICAgfVxuXG4gICAgb25FeGVjdXRlUm93QWN0aW9uKHJvdzogRGF0YVJvdywgYWN0aW9uOiBhbnkpIHtcbiAgICAgICAgbGV0IGFyZ3MgPSB7IHJvdzogcm93LCBhY3Rpb246IGFjdGlvbiB9O1xuICAgICAgICB0aGlzLmV4ZWN1dGVSb3dBY3Rpb24uZW1pdCh7IGFyZ3M6IGFyZ3MgfSk7XG4gICAgfVxufVxuIl19
